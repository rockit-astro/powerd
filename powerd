#!/usr/bin/env python3
#
# This file is part of powerd.
#
# powerd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# powerd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with powerd.  If not, see <http://www.gnu.org/licenses/>.

# pylint: disable=broad-except
# pylint: disable=too-few-public-methods

"""Frontend for interacting with the PDUs and UPSes via SNMP."""

import datetime
import subprocess
import Pyro4
import warwick.observatory as observatory

# Timeout in seconds for SNMP commands
SNMP_TIMEOUT = 2

class ParameterType:
    """Defines the way that an OID parameter should be handled"""
    Bool, ReadOnlyBool, Int, ReadOnlyInt, ReadOnlyGauge = range(5)

class ParameterOID:
    """Object ID string used by the SNMP device"""
    UPSStatus = '.1.3.6.1.4.1.318.1.1.1.4.1.1.0'
    UPSBatteryRemaining = '.1.3.6.1.4.1.318.1.1.1.2.2.1.0'
    UPSBatteryHealthy = '.1.3.6.1.4.1.318.1.1.1.2.2.4.0'
    UPSOutputLoad = '.1.3.6.1.4.1.318.1.1.1.4.2.3.0'
    PDUChannel1 = '.1.3.6.1.4.1.318.1.1.12.3.3.1.1.4.1'
    PDUChannel2 = '.1.3.6.1.4.1.318.1.1.12.3.3.1.1.4.2'
    PDUChannel3 = '.1.3.6.1.4.1.318.1.1.12.3.3.1.1.4.3'
    PDUChannel4 = '.1.3.6.1.4.1.318.1.1.12.3.3.1.1.4.4'
    PDUChannel5 = '.1.3.6.1.4.1.318.1.1.12.3.3.1.1.4.5'
    PDUChannel6 = '.1.3.6.1.4.1.318.1.1.12.3.3.1.1.4.6'
    PDUChannel7 = '.1.3.6.1.4.1.318.1.1.12.3.3.1.1.4.7'
    PDUChannel8 = '.1.3.6.1.4.1.318.1.1.12.3.3.1.1.4.8'
    PoEStatusPrefix = '.1.3.6.1.2.1.105.1.1.1.6.1.'
    PoESwitchPrefix = '.1.3.6.1.2.1.105.1.1.1.3.1.'

class APCDeviceParameter:
    """Data structure encapsulating a PDU/UPS parameter"""
    def __init__(self, name, oid_type, oid):
        self.name = name
        self.oid_type = oid_type
        self.oid = oid

    def parse_snmp_output(self, output):
        """Convert a snmp output string for this parameter into a python value"""
        parts = output.split(' ')

        if self.oid_type == ParameterType.ReadOnlyGauge and parts[-2] != 'Gauge32:':
            raise Exception('Unabled to parse Gauge32 from SNMP output: ' + output)
        elif self.oid_type != ParameterType.ReadOnlyGauge and parts[-2] != 'INTEGER:':
            raise Exception('Unabled to parse integer from SNMP output: ' + output)

        if self.oid_type == ParameterType.Bool or self.oid_type == ParameterType.ReadOnlyBool:
            return int(parts[-1]) == 1

        return int(parts[-1])

RACK_PDU_IP = '10.2.6.212'
RACK_PDU_PORTS = [
    APCDeviceParameter('rack_nuc', ParameterType.Bool, ParameterOID.PDUChannel1),
    APCDeviceParameter('telescope_12v', ParameterType.Bool, ParameterOID.PDUChannel2),
    APCDeviceParameter('telescope_80v', ParameterType.Bool, ParameterOID.PDUChannel3),
    APCDeviceParameter('vaisala', ParameterType.Bool, ParameterOID.PDUChannel4),
    APCDeviceParameter('microphone', ParameterType.Bool, ParameterOID.PDUChannel5),
    APCDeviceParameter('monitor', ParameterType.Bool, ParameterOID.PDUChannel6),
    APCDeviceParameter('light', ParameterType.Bool, ParameterOID.PDUChannel8)
]

TEL_PDU_IP = '10.2.6.213'
TEL_PDU_PORTS = [
    APCDeviceParameter('red_camera', ParameterType.Bool, ParameterOID.PDUChannel1),
    APCDeviceParameter('blue_camera', ParameterType.Bool, ParameterOID.PDUChannel2),
    APCDeviceParameter('telescope_nuc', ParameterType.Bool, ParameterOID.PDUChannel3),
    APCDeviceParameter('red_focus_motor', ParameterType.Bool, ParameterOID.PDUChannel7),
    APCDeviceParameter('red_focus_controller', ParameterType.Bool, ParameterOID.PDUChannel8)
]

MAIN_UPS_IP = '10.2.6.210'
MAIN_UPS_PARAMETERS = [
    APCDeviceParameter('main_ups_status', ParameterType.ReadOnlyInt, ParameterOID.UPSStatus),
    APCDeviceParameter('main_ups_battery_remaining', ParameterType.ReadOnlyGauge,
                       ParameterOID.UPSBatteryRemaining),
    APCDeviceParameter('main_ups_battery_healthy', ParameterType.ReadOnlyBool,
                       ParameterOID.UPSBatteryHealthy),
    APCDeviceParameter('main_ups_load', ParameterType.ReadOnlyGauge, ParameterOID.UPSOutputLoad),
]

DOME_UPS_IP = '10.2.6.211'
DOME_UPS_PARAMETERS = [
    APCDeviceParameter('dome_ups_status', ParameterType.ReadOnlyInt, ParameterOID.UPSStatus),
    APCDeviceParameter('dome_ups_battery_remaining', ParameterType.ReadOnlyGauge,
                       ParameterOID.UPSBatteryRemaining),
    APCDeviceParameter('dome_ups_battery_healthy', ParameterType.ReadOnlyBool,
                       ParameterOID.UPSBatteryHealthy),
    APCDeviceParameter('dome_ups_load', ParameterType.ReadOnlyGauge, ParameterOID.UPSOutputLoad),
]

class PoeDeviceParameter:
    """Data structure encapsulating a PoE parameter"""
    def __init__(self, name, port):
        self.name = name
        self.port = port

    def parse_snmp_output(self, output):
        """Convert a snmp output string for this parameter into a python value"""
        return int(output.split(' ')[-1]) == 3

RACK_SWITCH_IP = '10.2.6.214'
RACK_SWITCH_PARAMETERS = [
    PoeDeviceParameter('telescope_network', 1),
    PoeDeviceParameter('webcam', 3),
    PoeDeviceParameter('roomalert', 5),
]

class APCDevice:
    """Wrapper for querying an APC PDU or UPS via SNMP"""
    def __init__(self, ip, parameters):
        self._ip = ip
        self.parameters = parameters
        self.parameters_by_name = {p.name: p for p in parameters}

    def status(self):
        """Return a dictionary of parameter values for this device"""
        # Query all OIDs at once for efficiency
        oids = [p.oid for p in self.parameters]
        args = ['/usr/bin/snmpget', '-v', '1', '-c', 'public', self._ip] + oids
        output = subprocess.check_output(args, universal_newlines=True, timeout=SNMP_TIMEOUT)
        lines = output.strip().split('\n')

        # Return a dictionary of values keyed by parameter name
        return {k.name: k.parse_snmp_output(v) for k, v in zip(self.parameters, lines)}

    def get_parameter(self, parameter_name):
        """Returns the value of a named parameter"""
        if parameter_name not in self.parameters_by_name:
            return False

        parameter = self.parameters_by_name[parameter_name]
        args = ['/usr/bin/snmpget', '-v', '1', '-c', 'public', self._ip, parameter.oid]
        output = subprocess.check_output(args, universal_newlines=True, timeout=SNMP_TIMEOUT)
        return parameter.parse_snmp_output(output)

    def set_parameter(self, parameter_name, value):
        """Sets the value of a named parameter"""
        if parameter_name not in self.parameters_by_name:
            return False

        parameter = self.parameters_by_name[parameter_name]
        if parameter.oid_type == ParameterType.ReadOnlyInt:
            return False
        if parameter.oid_type == ParameterType.ReadOnlyBool:
            return False

        try:
            str_value = str(value)
            if parameter.oid_type == ParameterType.Bool:
                str_value = '1' if value else '2'

            args = ['/usr/bin/snmpset', '-v', '1', '-c', 'private', self._ip, parameter.oid,
                    'i', str_value]

            output = subprocess.check_output(args, universal_newlines=True, timeout=SNMP_TIMEOUT)
            return parameter.parse_snmp_output(output) == value
        except Exception as exception:
            print('{} ERROR: failed to send SNMP command: {}' \
                  .format(datetime.datetime.utcnow(), str(exception)))
            observatory.log.error('powerd', 'Failed to send SNMP command (' \
                                  + str(exception) + ')')
            return False

class PoeDevice:
    """Wrapper for querying an Netgear PoE switch UPS via SNMP"""
    def __init__(self, ip, parameters):
        self._ip = ip
        self.parameters = parameters
        self.parameters_by_name = {p.name: p for p in parameters}

    def status(self):
        """Return a dictionary of parameter values for this device"""
        # Query all OIDs at once for efficiency
        oids = [ParameterOID.PoEStatusPrefix + str(p.port) for p in self.parameters]
        args = ['/usr/bin/snmpget', '-v', '1', '-c', 'public', self._ip] + oids
        output = subprocess.check_output(args, universal_newlines=True, timeout=SNMP_TIMEOUT)
        lines = output.strip().split('\n')

        # Return a dictionary of values keyed by parameter name
        return {k.name: k.parse_snmp_output(v) for k, v in zip(self.parameters, lines)}

    def get_parameter(self, parameter_name):
        """Returns the value of a named parameter"""
        if parameter_name not in self.parameters_by_name:
            return False

        parameter = self.parameters_by_name[parameter_name]
        oid = ParameterOID.PoEStatusPrefix + str(parameter.port)
        args = ['/usr/bin/snmpget', '-v', '1', '-c', 'public', self._ip, oid]
        output = subprocess.check_output(args, universal_newlines=True, timeout=SNMP_TIMEOUT)
        return parameter.parse_snmp_output(output)

    def set_parameter(self, parameter_name, value):
        """Sets the value of a named parameter"""
        if parameter_name not in self.parameters_by_name:
            return False

        parameter = self.parameters_by_name[parameter_name]
        oid = ParameterOID.PoESwitchPrefix + str(parameter.port)

        try:
            str_value = '1' if value else '2'

            args = ['/usr/bin/snmpset', '-v', '1', '-c', 'private', self._ip, oid,
                    'i', str_value]
            output = subprocess.check_output(args, universal_newlines=True, timeout=SNMP_TIMEOUT)

            # The switch OID returns true/false, different to the status code that is
            # returned by the status OID and parsed by parse_snmp_output
            return (int(output.split(' ')[-1]) == 1) == value
        except Exception as exception:
            print('{} ERROR: failed to send SNMP command: {}' \
                  .format(datetime.datetime.utcnow(), str(exception)))
            observatory.log.error('powerd', 'Failed to send SNMP command (' \
                                  + str(exception) + ')')
            return False

class PowerDaemon:
    """Wraps a web request to the PDUs and UPSes"""
    def __init__(self):
        self._devices = [
            APCDevice(RACK_PDU_IP, RACK_PDU_PORTS),
            APCDevice(TEL_PDU_IP, TEL_PDU_PORTS),
            APCDevice(MAIN_UPS_IP, MAIN_UPS_PARAMETERS),
            APCDevice(DOME_UPS_IP, DOME_UPS_PARAMETERS),
            PoeDevice(RACK_SWITCH_IP, RACK_SWITCH_PARAMETERS),
        ]

        # Map of parameter name to device holding the parameter
        self._device_by_parameter = {}
        for device in self._devices:
            for parameter in device.parameters:
                self._device_by_parameter.update({parameter.name: device})

    @Pyro4.expose
    def last_measurement(self):
        """Query the latest valid measurement.
        May return None if no data is available"""
        try:
            data = {'date': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')}
            for device in self._devices:
                data.update(device.status())
            return data

        except Exception as exception:
            print('{} ERROR: failed to query SNMP: {}' \
                  .format(datetime.datetime.utcnow(), str(exception)))
            observatory.log.error('powerd', 'Failed to query device (' \
                                  + str(exception) + ')')
            return None

    @Pyro4.expose
    def switch(self, name, enable):
        """Switch a named UPS switch parameter on or off"""
        if name not in self._device_by_parameter:
            return False

        ret = self._device_by_parameter[name].set_parameter(name, enable)
        observatory.log.info('powerd', 'Switched ' + name + ' ' + ('on' if enable else 'off'))
        return ret

    @Pyro4.expose
    def value(self, name):
        """Query the value of a named parameter"""
        if name not in self._device_by_parameter:
            return False

        return self._device_by_parameter[name].get_parameter(name)

if __name__ == '__main__':
    observatory.daemons.onemetre_power.launch(PowerDaemon())
